name: Build & Deploy to AKS

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Docker Login to ACR
      uses: docker/login-action@v3
      with:
        registry: ${{ secrets.ACR_LOGIN_SERVER }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Build & Push Image
      run: |
        IMAGE=${{ secrets.ACR_LOGIN_SERVER }}/hello-aks:${{ github.sha }}
        docker build -t $IMAGE .
        docker push $IMAGE
        echo "IMAGE=$IMAGE" >> $GITHUB_ENV

    - name: Set AKS context
      uses: azure/aks-set-context@v4
      with:
        resource-group: ${{ secrets.AZURE_RESOURCE_GROUP }}
        cluster-name:  ${{ secrets.AZURE_AKS_CLUSTER }}

    # Option A: render k8s.yaml tag and apply (default)
    - name: Render manifest with tag and apply
      run: |
        sed "s#__TAG__#${{ github.sha }}#g" k8s.yaml > k8s.rendered.yaml
        kubectl apply -f k8s.rendered.yaml
        kubectl rollout status deploy/hello-aks

    # Option B (disabled): directly set image on existing deploy
    # - name: Update Deployment image
    #   if: always()
    #   run: |
    #     kubectl set image deploy/hello-aks hello-aks=$IMAGE
    #     kubectl rollout status deploy/hello-aks

    - name: Print Service External IP (if using LoadBalancer)
      run: |
        kubectl get svc hello-aks-svc || true
        for i in {1..20}; do
          IP=$(kubectl get svc hello-aks-svc -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
          [ -n "$IP" ] && break
          echo "waiting for EXTERNAL-IP... ($i/20)"; sleep 6
        done
        echo "EXTERNAL-IP=${IP:-<via Ingress if using Ingress>}"
